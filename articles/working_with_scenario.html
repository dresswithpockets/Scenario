<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Working With Scenario </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Working With Scenario ">
    <meta name="generator" content="docfx 2.58.0.0">
    
    <link rel="shortcut icon" href="../favicon.ico">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="working-with-scenario">Working With Scenario</h1>

<p>Approx. 10 minute read.</p>
<p>This doc is a bit of a deeper dive with how each component in a typical Scenario works.</p>
<h2 id="creating-a-scenario">Creating a scenario</h2>
<p>Scenarios are, at their core, just a collection of services (dependencies) and data (resources). You may add to those dependencies and resources freely via <code>ScenarioBuilder</code>:</p>
<pre><code class="lang-cs">var builder = new ScenarioBuilder();
</code></pre>
<p>From here you may add a dependency necessary for the scenario - the <code>Use</code> method allows you to add services to the service collection, not dissimilar to <code>ConfigureServices(IServiceCollection)</code> in WebHost Startup classes:</p>
<pre><code class="lang-cs">builder.Use(services =&gt; services.AddTransient&lt;IUserService, UserService&gt;());
</code></pre>
<p>For the sake of our example, lets create a user given this hypothetical <code>IUserService</code> - the <code>With</code> method takes a factory method which is passed an <code>IServiceScope</code>, exposing all of the dependencies we've added to the scenario thus far:</p>
<pre><code class="lang-cs">builder.With(async scope =&gt; await scope.ServiceProvider.GetRequiredService&lt;IUserService&gt;().CreateUserAsync());
</code></pre>
<p>Now we've created a builder with an <code>IUserService</code> dependency, and a resource factory for creating a user; however, that factory hasn't actually executed yet. We need to build the scenario from the builder for that:</p>
<pre><code class="lang-cs">var scenario = await builder.BuildAsync();
</code></pre>
<p>If we put that all together, this is what we end up with:</p>
<pre><code class="lang-cs">var scenario = await new ScenarioBuilder()
    .Use(services =&gt; services.AddTransient&lt;IUserService, UserService&gt;())
    .With(async scope =&gt; await scope.ServiceProvider.GetRequiredService&lt;IUserService&gt;().CreateUserAsync())
    .BuildAsync();
</code></pre>
<h2 id="using-a-scenario">Using a scenario</h2>
<p>Given what we have so far:</p>
<pre><code class="lang-cs">var scenario = await new ScenarioBuilder()
    .Use(services =&gt; services.AddTransient&lt;IUserService, UserService&gt;())
    .With(async scope =&gt; await scope.ServiceProvider.GetRequiredService&lt;IUserService&gt;().CreateUserAsync())
    .BuildAsync();
</code></pre>
<p>we've created a User resource - we may want to use that resource outside of the scenario and within our test. The quickest way to get access to the resource is via the result callback available as the 2nd parameter in the <code>With</code> function, which will be invoked just after the resource is created, with the result of the factory function.</p>
<pre><code class="lang-cs">User user = null!;
//...
    .With(async scope =&gt; await scope.ServiceProvider.GetRequiredService&lt;IUserService&gt;().CreateUserAsync(),
        u =&gt; user = (User)u);
//...
</code></pre>
<p>After <code>BuildAsync</code> gets called, the factory method gets invoked &amp; the result of it gets passed into the callback, so by the time <code>BuildAsync</code> finishes, <code>user</code> will be occupied by the value established within the factory method. Lets validate this behaviour by taking out a scope on the scenario &amp; doing an assertion based on the result of a hypothetical api in our hypothetical service:</p>
<pre><code class="lang-cs">using var scope = scenario.CreateScope();
var userService = scope.ServiceProvider.GetRequiredService&lt;IUserService&gt;();

var retrievedUser = await userService.GetUserById(user!.Id);

Assert.NotNull(retirevedUser);
Assert.Equal(user.Id, retrievedUser.Id);
</code></pre>
<p>This ultimately asserts that <code>GetUserById</code> works as intended... its a unit test! Lets put it all together to get the bigger picture:</p>
<pre><code class="lang-cs">[Fact]
public async Task UserService_GetsUserById()
{
    // arrange
    User user = null!;
    var scenario = await new ScenarioBuilder()
        .Use(services =&gt; services.AddTransient&lt;IUserService, UserService&gt;())
        .With(async scope =&gt; await scope.ServiceProvider.GetRequiredService&lt;IUserService&gt;().CreateUserAsync(),
            u =&gt; user = (User)u);
        .BuildAsync();

    // act
    using var scope = scenario.CreateScope();
    var userService = scope.ServiceProvider.GetRequiredService&lt;IUserService&gt;();

    var retrievedUser = await userService.GetUserByIdAsync(user!.Id);

    // assert
    Assert.NotNull(retirevedUser);
    Assert.Equal(user.Id, retrievedUser.Id);
}
</code></pre>
<h2 id="refactoring-common-utilities">Refactoring common utilities</h2>
<p>Lets take a look at our current unit test:</p>
<pre><code class="lang-cs">[Fact]
public async Task UserService_GetsUserById()
{
    // arrange
    User user = null!;
    var scenario = await new ScenarioBuilder()
        .Use(services =&gt; services.AddTransient&lt;IUserService, UserService&gt;())
        .With(async scope =&gt; await scope.ServiceProvider.GetRequiredService&lt;IUserService&gt;().CreateUserAsync(),
            u =&gt; user = (User)u);
        .BuildAsync();

    // act
    using var scope = scenario.CreateScope();
    var userService = scope.ServiceProvider.GetRequiredService&lt;IUserService&gt;();

    var retrievedUser = await userService.GetUserByIdAsync(user!.Id);

    // assert
    Assert.NotNull(retirevedUser);
    Assert.Equal(user.Id, retrievedUser.Id);
}
</code></pre>
<p>This is pretty good; however, we might want to reuse some of the functionality we have here. Lets move our <code>Use</code> and <code>With</code> code into a couple common extension methods that we can call upon from within any unit test:</p>
<pre><code class="lang-cs">public static class ScenarioUserExtensions
{
    public static TScenarioBuilder UseUsers&lt;TScenarioBuilder&gt;(this TScenarioBuilder builder)
        where TScenarioBuilder : IScenarioBuilder
        =&gt; (TScenarioBuilder) builder.Use(services =&gt; services.AddTransient&lt;IUserService, UserService&gt;());
    
    public static TScenarioBuilder WithUser&lt;TScenarioBuilder&gt;(this TScenarioBuilder builder, Action&lt;User&gt;? resultCallback = null)
        where TScenarioBuilder : IScenarioBuilder
        =&gt; (TScenarioBuilder) builder.With(
                async scope =&gt; await scope.ServiceProvider.GetRequiredService&lt;IUserService&gt;().CreateUserAsync(),
                u =&gt; user = (User)u);
}
</code></pre>
<p>Thats is quite a bit more verbose ((see how to make it much less verbose here)[source_gen.html]); while we make that tradeoff, what we get back is reusability &amp; simplifying our unit tests:</p>
<pre><code class="lang-cs">[Fact]
public async Task UserService_GetsUserById()
{
    // arrange
    User user = null!;
    var scenario = await new ScenarioBuilder()
        .UseUsers()
        .WithUser(u =&gt; user = u);
        .BuildAsync();

    // act
    using var scope = scenario.CreateScope();
    var userService = scope.ServiceProvider.GetRequiredService&lt;IUserService&gt;();

    var retrievedUser = await userService.GetUserByIdAsync(user!.Id);

    // assert
    Assert.NotNull(retirevedUser);
    Assert.Equal(user.Id, retrievedUser.Id);
}

// here is another hypotetical unit test using those extension methods we just wrote
[Fact]
public async Task UserService_GetsAllUsers()
{
    // arrange
    var users = new List&lt;User&gt;();
    var scenario = await new ScenarioBuilder()
        .UseUsers()
        .WithUser(u =&gt; users.Add(u))
        .WithUser(u =&gt; users.Add(u))
        .BuildAsync();

    // act
    using var scope = scenario.CreateScope();
    var userService = scope.ServiceProvider.GetRequiredService&lt;IUserService&gt;();

    var retrievedUsers = await userService.GetAllUsersAsync().ToImmutableList();

    // assert
    Assert.Equal(users.Count, retrievedUsers.Count)
    foreach (var retrievedUser in retrievedUsers)
        Assert.NotNull(users.SingleOrDefault(u =&gt; u.Id == retrievedUser.Id));
}
</code></pre>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/dresswithpockets/Scenario/blob/main//__w/Scenario/Scenario/docfx/articles/working_with_scenario.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <div class="toggle-mode">
                <div class="icon">
                  <i aria-hidden="true">☀</i>
                </div>
                <label class="switch">
                  <input type="checkbox" id="switch-style">
                  <span class="slider round"></span>
                </label>
                <div class="icon">
                  <i aria-hidden="true">☾</i>
                </div>
              </div>
          
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <h5>In This Article</h5>
              <div></div>
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            <div class="pull-left">
              
              <span>Generated by <strong>DocFX</strong></span>
            </div>
            <div class="toggle-mode pull-right visible-sm visible-xs">
              <div class="icon">
                <i aria-hidden="true">☀</i>
              </div>
              <label class="switch">
                <input type="checkbox" id="switch-style-m">
                <span class="slider round"></span>
              </label>
              <div class="icon">
                <i aria-hidden="true">☾</i>
              </div>
            </div>
          </div>
        </div>
        <script type="text/javascript" src="../styles/toggle-theme.js"></script>
      </footer>    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
